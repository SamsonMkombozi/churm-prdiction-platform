from app.extensions import db
from datetime import datetime
import json
import logging

logger = logging.getLogger(__name__)

class Company(db.Model):
    __tablename__ = 'companies'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    slug = db.Column(db.String(100), nullable=False, unique=True)
    description = db.Column(db.Text)
    industry = db.Column(db.String(100))
    website = db.Column(db.String(255))
    crm_api_url = db.Column(db.String(255))
    encrypted_api_key = db.Column(db.Text)
    settings = db.Column(db.Text)
    last_sync_at = db.Column(db.DateTime)
    sync_status = db.Column(db.String(20))
    sync_error = db.Column(db.Text)
    total_syncs = db.Column(db.Integer)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    api_token = db.Column(db.String(255))
    api_base_url = db.Column(db.String(255))
    postgresql_host = db.Column(db.String(255))
    postgresql_port = db.Column(db.Integer, default=5432)
    postgresql_database = db.Column(db.String(100))
    postgresql_username = db.Column(db.String(100))
    postgresql_password_encrypted = db.Column(db.Text)
    api_key_encrypted = db.Column(db.Text)
    api_username = db.Column(db.String(100))
    api_password_encrypted = db.Column(db.Text)
    logo_url = db.Column(db.String(255))
    
    # FIXED: Use back_populates instead of backref
    users = db.relationship('User', back_populates='company', lazy=True)
    customers = db.relationship('Customer', back_populates='company', lazy=True, cascade='all, delete-orphan')
    
    def __repr__(self):
        return f'<Company {self.name}>'
    
    def get_setting(self, key, default=None):
        try:
            if hasattr(self, key):
                value = getattr(self, key, None)
                if value is not None:
                    return value
            return default
        except Exception as e:
            logger.error(f"Error getting setting: {e}")
            return default
    
    def update_settings(self, settings_dict):
        try:
            for key, value in settings_dict.items():
                if hasattr(self, key):
                    setattr(self, key, value)
            
            if hasattr(self, 'updated_at'):
                self.updated_at = datetime.utcnow()
            
            db.session.commit()
        except Exception as e:
            logger.error(f"Error updating settings: {e}")
            db.session.rollback()
            raise
    
    def has_postgresql_config(self):
        """Check PostgreSQL configuration"""
        try:
            host = self.postgresql_host
            database = self.postgresql_database
            username = self.postgresql_username
            password = self.postgresql_password_encrypted
            
            has_config = bool(
                host and host.strip() and
                database and database.strip() and
                username and username.strip() and
                password and password.strip()
            )
            
            return has_config
        except Exception as e:
            logger.error(f"Error checking PostgreSQL config: {e}")
            return False
    
    def has_api_config(self):
        """Check if API connection is configured"""
        try:
            api_url = self.api_base_url or self.crm_api_url
            return bool(api_url and api_url.strip())
        except Exception as e:
            logger.error(f"Error checking API config: {e}")
            return False
    
    def get_preferred_sync_method(self):
        """Get preferred sync method"""
        try:
            if self.has_postgresql_config():
                return 'postgresql'
            elif self.has_api_config():
                return 'api'
            else:
                return 'none'
        except Exception as e:
            logger.error(f"Error getting preferred sync method: {e}")
            return 'none'
    
    def get_postgresql_config(self):
        """Get complete PostgreSQL configuration"""
        try:
            return {
                'host': self.postgresql_host,
                'port': self.postgresql_port or 5432,
                'database': self.postgresql_database,
                'username': self.postgresql_username,
                'password': self.get_postgresql_password()
            }
        except Exception as e:
            logger.error(f"Error getting PostgreSQL config: {e}")
            return {'host': None, 'port': 5432, 'database': None, 'username': None, 'password': None}
    
    def get_api_config(self):
        """Get complete API configuration"""
        try:
            return {
                'base_url': self.api_base_url or self.crm_api_url,
                'username': self.api_username,
                'password': self.get_api_password(),
                'api_key': self.get_api_key(),
                'token': self.api_token
            }
        except Exception as e:
            logger.error(f"Error getting API config: {e}")
            return {'base_url': None, 'username': None, 'password': None, 'api_key': None, 'token': None}
    
    def get_postgresql_password(self):
        """Get decrypted PostgreSQL password"""
        try:
            if self.postgresql_password_encrypted:
                try:
                    from app.utils.encryption import decrypt_value
                    return decrypt_value(self.postgresql_password_encrypted)
                except ImportError:
                    return self.postgresql_password_encrypted
            return None
        except Exception as e:
            logger.warning(f"Error getting PostgreSQL password: {e}")
            return self.postgresql_password_encrypted
    
    def get_api_password(self):
        """Get decrypted API password"""
        try:
            if self.api_password_encrypted:
                try:
                    from app.utils.encryption import decrypt_value
                    return decrypt_value(self.api_password_encrypted)
                except ImportError:
                    return self.api_password_encrypted
            return None
        except Exception as e:
            logger.warning(f"Error getting API password: {e}")
            return self.api_password_encrypted
    
    def get_api_key(self):
        """Get decrypted API key"""
        try:
            if self.api_key_encrypted:
                try:
                    from app.utils.encryption import decrypt_value
                    return decrypt_value(self.api_key_encrypted)
                except ImportError:
                    return self.api_key_encrypted
            elif self.encrypted_api_key:
                try:
                    from app.utils.encryption import decrypt_value
                    return decrypt_value(self.encrypted_api_key)
                except ImportError:
                    return self.encrypted_api_key
            return None
        except Exception as e:
            logger.warning(f"Error getting API key: {e}")
            return self.api_key_encrypted or self.encrypted_api_key
    
    def get_customer_count(self):
        """Get total number of customers"""
        try:
            from app.models.customer import Customer
            return Customer.query.filter_by(company_id=self.id).count()
        except Exception as e:
            logger.error(f"Error getting customer count: {e}")
            return 0
    
    def get_active_customer_count(self):
        """Get count of active customers"""
        try:
            from app.models.customer import Customer
            return Customer.query.filter_by(
                company_id=self.id,
                status='active'
            ).count()
        except Exception as e:
            logger.error(f"Error getting active customer count: {e}")
            return 0
    
    def get_high_risk_customer_count(self):
        """Get count of high-risk customers"""
        try:
            from app.models.customer import Customer
            return Customer.query.filter_by(
                company_id=self.id,
                churn_risk='high'
            ).count()
        except Exception as e:
            logger.error(f"Error getting high risk customer count: {e}")
            return 0
    
    def get_ticket_count(self):
        """Get total number of tickets"""
        try:
            from app.models.ticket import Ticket
            return Ticket.query.filter_by(company_id=self.id).count()
        except Exception as e:
            logger.error(f"Error getting ticket count: {e}")
            return 0
    
    def get_payment_count(self):
        """Get total number of payments"""
        try:
            from app.models.payment import Payment
            return Payment.query.filter_by(company_id=self.id).count()
        except Exception as e:
            logger.error(f"Error getting payment count: {e}")
            return 0
    
    def get_active_user_count(self):
        """Get count of active users"""
        try:
            return len([u for u in self.users if getattr(u, 'is_active', True)])
        except Exception as e:
            logger.error(f"Error getting active user count: {e}")
            return 1
    
    def mark_sync_started(self):
        """Mark that a sync operation has started"""
        try:
            self.sync_status = 'syncing'
            self.sync_error = None
            db.session.commit()
            logger.info(f"Company {self.name}: Sync started")
        except Exception as e:
            logger.error(f"Error marking sync started: {e}")
            db.session.rollback()
    
    def mark_sync_completed(self):
        """Mark that a sync operation completed successfully"""
        try:
            self.sync_status = 'completed'
            self.last_sync_at = datetime.utcnow()
            self.sync_error = None
            self.total_syncs = (self.total_syncs or 0) + 1
            db.session.commit()
            logger.info(f"Company {self.name}: Sync completed successfully (Total syncs: {self.total_syncs})")
        except Exception as e:
            logger.error(f"Error marking sync completed: {e}")
            db.session.rollback()
    
    def mark_sync_failed(self, error_message):
        """Mark that a sync operation failed"""
        try:
            self.sync_status = 'failed'
            self.sync_error = error_message[:500] if error_message else 'Unknown error'
            db.session.commit()
            logger.error(f"Company {self.name}: Sync failed - {error_message}")
        except Exception as e:
            logger.error(f"Error marking sync failed: {e}")
            db.session.rollback()