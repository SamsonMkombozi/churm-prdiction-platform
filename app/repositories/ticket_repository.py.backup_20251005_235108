"""
Ticket Repository - FIXED VERSION
app/repositories/ticket_repository.py

Handles missing customer IDs gracefully
"""
from datetime import datetime
from typing import List, Optional, Dict
from app.extensions import db
from app.models.ticket import Ticket
from app.models.customer import Customer
from app.models.company import Company
import logging

logger = logging.getLogger(__name__)


class TicketRepository:
    """Repository for ticket data operations"""
    
    def __init__(self, company: Company):
        self.company = company
        self.company_id = company.id
    
    def get_by_id(self, ticket_id: int) -> Optional[Ticket]:
        return Ticket.query.filter_by(id=ticket_id, company_id=self.company_id).first()
    
    def get_by_crm_id(self, crm_ticket_id: str) -> Optional[Ticket]:
        return Ticket.query.filter_by(company_id=self.company_id, crm_ticket_id=crm_ticket_id).first()
    
    def get_all(self, limit: int = None) -> List[Ticket]:
        query = Ticket.query.filter_by(company_id=self.company_id)
        if limit:
            query = query.limit(limit)
        return query.all()
    
    def get_by_status(self, status: str) -> List[Ticket]:
        return Ticket.query.filter_by(company_id=self.company_id, status=status).all()
    
    def get_open_tickets(self) -> List[Ticket]:
        return Ticket.query.filter_by(company_id=self.company_id, status='open').all()
    
    def get_by_customer(self, customer_id: int) -> List[Ticket]:
        return Ticket.query.filter_by(company_id=self.company_id, customer_id=customer_id).order_by(Ticket.created_at.desc()).all()
    
    def get_by_priority(self, priority: str) -> List[Ticket]:
        return Ticket.query.filter_by(company_id=self.company_id, priority=priority).all()
    
    def get_recent(self, limit: int = 10) -> List[Ticket]:
        return Ticket.query.filter_by(company_id=self.company_id).order_by(Ticket.created_at.desc()).limit(limit).all()
    
    def create(self, ticket_data: Dict) -> Optional[Ticket]:
        """
        Create new ticket from dictionary
        ✅ FIXED: Returns None if customer not found
        """
        # Try multiple possible field names for customer ID
        customer_crm_id = (
            ticket_data.get('customer_id') or 
            ticket_data.get('customerId') or 
            ticket_data.get('cust_id') or
            ticket_data.get('customer')
        )
        
        customer = None
        if customer_crm_id:
            customer = Customer.query.filter_by(
                company_id=self.company_id,
                crm_customer_id=str(customer_crm_id)
            ).first()
            
            if not customer:
                logger.warning(
                    f"Skipping ticket {ticket_data.get('id')} - "
                    f"Customer {customer_crm_id} not found"
                )
                return None
        else:
            logger.warning(
                f"Skipping ticket {ticket_data.get('id')} - "
                f"No customer_id provided"
            )
            return None
        
        ticket = Ticket(
            company_id=self.company_id,
            customer_id=customer.id,  # Now guaranteed to be valid
            crm_ticket_id=ticket_data.get('id'),
            ticket_number=ticket_data.get('ticket_number'),
            title=ticket_data.get('title'),
            description=ticket_data.get('description'),
            category=ticket_data.get('category'),
            priority=ticket_data.get('priority', 'medium'),
            status=ticket_data.get('status', 'open'),
            resolution=ticket_data.get('resolution'),
            resolved_at=self._parse_date(ticket_data.get('resolved_at')),
            assigned_to=ticket_data.get('assigned_to'),
            department=ticket_data.get('department'),
            synced_at=datetime.utcnow()
        )
        
        if ticket.resolved_at:
            ticket.calculate_resolution_time()
        
        db.session.add(ticket)
        return ticket
    
    def update(self, ticket: Ticket, ticket_data: Dict) -> Ticket:
        """Update existing ticket"""
        ticket.ticket_number = ticket_data.get('ticket_number', ticket.ticket_number)
        ticket.title = ticket_data.get('title', ticket.title)
        ticket.description = ticket_data.get('description', ticket.description)
        ticket.category = ticket_data.get('category', ticket.category)
        ticket.priority = ticket_data.get('priority', ticket.priority)
        ticket.status = ticket_data.get('status', ticket.status)
        ticket.resolution = ticket_data.get('resolution', ticket.resolution)
        ticket.assigned_to = ticket_data.get('assigned_to', ticket.assigned_to)
        ticket.department = ticket_data.get('department', ticket.department)
        
        if 'resolved_at' in ticket_data:
            ticket.resolved_at = self._parse_date(ticket_data['resolved_at'])
            if ticket.resolved_at:
                ticket.calculate_resolution_time()
        
        ticket.updated_at = datetime.utcnow()
        ticket.synced_at = datetime.utcnow()
        return ticket
    
    def create_or_update(self, ticket_data: Dict) -> Optional[bool]:
        """
        Create new ticket or update existing one
        ✅ FIXED: Returns None if ticket skipped
        """
        crm_id = ticket_data.get('id')
        
        if not crm_id:
            logger.warning("Ticket data missing 'id' field - skipping")
            return None
        
        ticket = self.get_by_crm_id(str(crm_id))
        
        if ticket:
            self.update(ticket, ticket_data)
            return False
        else:
            created_ticket = self.create(ticket_data)
            return True if created_ticket else None
    
    def delete(self, ticket: Ticket):
        db.session.delete(ticket)
    
    def count(self) -> int:
        return Ticket.query.filter_by(company_id=self.company_id).count()
    
    def count_by_status(self, status: str) -> int:
        return Ticket.query.filter_by(company_id=self.company_id, status=status).count()
    
    def count_by_priority(self, priority: str) -> int:
        return Ticket.query.filter_by(company_id=self.company_id, priority=priority).count()
    
    def get_paginated(self, page: int = 1, per_page: int = 20, status: str = None, priority: str = None):
        query = Ticket.query.filter_by(company_id=self.company_id)
        if status:
            query = query.filter_by(status=status)
        if priority:
            query = query.filter_by(priority=priority)
        return query.order_by(Ticket.created_at.desc()).paginate(page=page, per_page=per_page, error_out=False)
    
    def get_average_resolution_time(self) -> float:
        avg = db.session.query(db.func.avg(Ticket.resolution_time_hours)).filter(
            Ticket.company_id == self.company_id,
            Ticket.resolution_time_hours.isnot(None)
        ).scalar()
        return avg or 0.0
    
    @staticmethod
    def _parse_date(date_string: str) -> Optional[datetime]:
        if not date_string:
            return None
        try:
            return datetime.fromisoformat(date_string.replace('Z', '+00:00'))
        except (ValueError, AttributeError):
            return None