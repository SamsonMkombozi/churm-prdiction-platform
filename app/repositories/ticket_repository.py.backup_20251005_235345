"""
Ticket Repository - FINAL FIXED VERSION
app/repositories/ticket_repository.py

Uses 'customer_no' field for customer reference
"""
from datetime import datetime
from typing import List, Optional, Dict
from app.extensions import db
from app.models.ticket import Ticket
from app.models.customer import Customer
from app.models.company import Company
import logging

logger = logging.getLogger(__name__)


class TicketRepository:
    """Repository for ticket data operations"""
    
    def __init__(self, company: Company):
        self.company = company
        self.company_id = company.id
    
    def get_by_id(self, ticket_id: int) -> Optional[Ticket]:
        return Ticket.query.filter_by(id=ticket_id, company_id=self.company_id).first()
    
    def get_by_crm_id(self, crm_ticket_id: str) -> Optional[Ticket]:
        return Ticket.query.filter_by(company_id=self.company_id, crm_ticket_id=crm_ticket_id).first()
    
    def get_all(self, limit: int = None) -> List[Ticket]:
        query = Ticket.query.filter_by(company_id=self.company_id)
        if limit:
            query = query.limit(limit)
        return query.all()
    
    def get_by_status(self, status: str) -> List[Ticket]:
        return Ticket.query.filter_by(company_id=self.company_id, status=status).all()
    
    def get_open_tickets(self) -> List[Ticket]:
        return Ticket.query.filter_by(company_id=self.company_id, status='open').all()
    
    def get_by_customer(self, customer_id: int) -> List[Ticket]:
        return Ticket.query.filter_by(company_id=self.company_id, customer_id=customer_id).order_by(Ticket.created_at.desc()).all()
    
    def get_by_priority(self, priority: str) -> List[Ticket]:
        return Ticket.query.filter_by(company_id=self.company_id, priority=priority).all()
    
    def get_recent(self, limit: int = 10) -> List[Ticket]:
        return Ticket.query.filter_by(company_id=self.company_id).order_by(Ticket.created_at.desc()).limit(limit).all()
    
    def create(self, ticket_data: Dict) -> Optional[Ticket]:
        """
        Create new ticket from dictionary
        ✅ FIXED: Uses 'customer_no' field for customer reference
        """
        # ✅ FIX: Use 'customer_no' field (this is how your CRM stores customer ID)
        customer_crm_id = (
            ticket_data.get('customer_no') or      # Primary field in your CRM
            ticket_data.get('customer_id') or      # Standard fallback
            ticket_data.get('customerId') or 
            ticket_data.get('cust_id')
        )
        
        customer = None
        if customer_crm_id:
            customer = Customer.query.filter_by(
                company_id=self.company_id,
                crm_customer_id=str(customer_crm_id)
            ).first()
            
            if not customer:
                logger.warning(
                    f"Skipping ticket {ticket_data.get('id')} - "
                    f"Customer {customer_crm_id} not found"
                )
                return None
        else:
            logger.warning(
                f"Skipping ticket {ticket_data.get('id')} - "
                f"No customer_no provided"
            )
            return None
        
        # Parse dates
        created_at = self._parse_date(ticket_data.get('created_at'))
        resolved_at = self._parse_date(ticket_data.get('outcome_date'))
        
        ticket = Ticket(
            company_id=self.company_id,
            customer_id=customer.id,  # Now guaranteed to be valid
            crm_ticket_id=str(ticket_data.get('id')),
            ticket_number=ticket_data.get('id'),  # Use ID as ticket number if not provided
            title=ticket_data.get('subject'),
            description=ticket_data.get('message'),
            category=ticket_data.get('category_id'),
            priority=ticket_data.get('priority', 'medium').lower(),
            status=self._normalize_status(ticket_data.get('status', 'open')),
            resolution=ticket_data.get('solutions_checklist'),
            resolved_at=resolved_at,
            assigned_to=str(ticket_data.get('assigned_to')) if ticket_data.get('assigned_to') else None,
            department=str(ticket_data.get('department_id')) if ticket_data.get('department_id') else None,
            created_at=created_at or datetime.utcnow(),
            synced_at=datetime.utcnow()
        )
        
        if ticket.resolved_at and ticket.created_at:
            ticket.calculate_resolution_time()
        
        db.session.add(ticket)
        return ticket
    
    def update(self, ticket: Ticket, ticket_data: Dict) -> Ticket:
        """Update existing ticket"""
        ticket.title = ticket_data.get('subject', ticket.title)
        ticket.description = ticket_data.get('message', ticket.description)
        ticket.category = ticket_data.get('category_id', ticket.category)
        ticket.priority = ticket_data.get('priority', ticket.priority).lower()
        ticket.status = self._normalize_status(ticket_data.get('status', ticket.status))
        ticket.resolution = ticket_data.get('solutions_checklist', ticket.resolution)
        ticket.assigned_to = str(ticket_data.get('assigned_to')) if ticket_data.get('assigned_to') else ticket.assigned_to
        ticket.department = str(ticket_data.get('department_id')) if ticket_data.get('department_id') else ticket.department
        
        if 'outcome_date' in ticket_data:
            ticket.resolved_at = self._parse_date(ticket_data['outcome_date'])
            if ticket.resolved_at:
                ticket.calculate_resolution_time()
        
        ticket.updated_at = datetime.utcnow()
        ticket.synced_at = datetime.utcnow()
        return ticket
    
    def create_or_update(self, ticket_data: Dict) -> Optional[bool]:
        """
        Create new ticket or update existing one
        Returns: True if created, False if updated, None if skipped
        """
        crm_id = ticket_data.get('id')
        
        if not crm_id:
            logger.warning("Ticket data missing 'id' field - skipping")
            return None
        
        ticket = self.get_by_crm_id(str(crm_id))
        
        if ticket:
            self.update(ticket, ticket_data)
            return False
        else:
            created_ticket = self.create(ticket_data)
            return True if created_ticket else None
    
    def delete(self, ticket: Ticket):
        db.session.delete(ticket)
    
    def count(self) -> int:
        return Ticket.query.filter_by(company_id=self.company_id).count()
    
    def count_by_status(self, status: str) -> int:
        return Ticket.query.filter_by(company_id=self.company_id, status=status).count()
    
    def count_by_priority(self, priority: str) -> int:
        return Ticket.query.filter_by(company_id=self.company_id, priority=priority).count()
    
    def get_paginated(self, page: int = 1, per_page: int = 20, status: str = None, priority: str = None):
        query = Ticket.query.filter_by(company_id=self.company_id)
        if status:
            query = query.filter_by(status=status)
        if priority:
            query = query.filter_by(priority=priority)
        return query.order_by(Ticket.created_at.desc()).paginate(page=page, per_page=per_page, error_out=False)
    
    def get_average_resolution_time(self) -> float:
        avg = db.session.query(db.func.avg(Ticket.resolution_time_hours)).filter(
            Ticket.company_id == self.company_id,
            Ticket.resolution_time_hours.isnot(None)
        ).scalar()
        return avg or 0.0
    
    @staticmethod
    def _parse_date(date_string: str) -> Optional[datetime]:
        if not date_string:
            return None
        try:
            return datetime.fromisoformat(date_string.replace('Z', '+00:00'))
        except (ValueError, AttributeError):
            try:
                # Handle format like "2024-10-01 09:34:50"
                return datetime.strptime(date_string, '%Y-%m-%d %H:%M:%S')
            except:
                return None
    
    @staticmethod
    def _normalize_status(status: str) -> str:
        """Normalize ticket status to standard values"""
        if not status:
            return 'open'
        
        status_lower = status.lower()
        
        # Map CRM statuses to standard statuses
        if status_lower in ['closed', 'resolved', 'completed']:
            return 'closed'
        elif status_lower in ['open', 'new']:
            return 'open'
        elif status_lower in ['in progress', 'in_progress', 'working']:
            return 'in_progress'
        else:
            return 'open'  # Default